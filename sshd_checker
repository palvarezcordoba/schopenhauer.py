#!/usr/bin/env python3
import re
import logging
from os import popen, path
from sys import stderr

import yaml

logging.basicConfig(level=logging.DEBUG,
                    format="[%(levelname)s::%(name)s] %(message)s")


class SSHConf:

    def __init__(self, conf):
        self.conf = [x.split(' ', 1) for x in conf.rsplit('\n')]
        self.confdict = dict()
        for x in self.conf:
            try:
                if x[0] in self.confdict.keys():
                    self.confdict[x[0]] = (self.confdict[x[0]], x[1])
                else:
                    self.confdict.update({x[0]: x[1]})
            except:
                pass

    def __getitem__(self, x):
        return self.confdict[x]

    def getOptions(self):
        return self.confdict.keys()


class SSHCheck:

    def __init__(self):
        with popen("/usr/sbin/sshd -T") as p:
            sshd_config = p.read()
        self._sshd = SSHConf(sshd_config)
        self._log = logging.getLogger(self.__class__.__name__)

    def root(self):
        if self._sshd["permitrootlogin"] != "no":
            self._log.error(
                "Disable root login.")

    def port(self):
        if self._sshd['port'] == '22':
            self._log.error("Port number should not be the default (22).")

    def logingracetime(self):
        if int(self._sshd["logingracetime"]) > 25:
            self._log.error(
                "LoginGraceTime is very high.")

    def passauthentication(self):
        if self._sshd["passwordauthentication"] == 'yes' or self._sshd["challengeresponseauthentication"] == 'yes':
            self._log.error("Disable keyboard-interactive and use ssh keys instead (or combine it, for example ssh keys + OTP codes). Make sure than PasswordAuthentication and ChallengeResponseAuthentication is both disabled.")

    def TFA(self):
        with open("/etc/pam.d/sshd", 'r') as f:
            sshd_pam = f.read()
        if not re.match("\s*auth\s*required\s*pam_google_authenticator.so*", sshd_pam):
            self._log.error("It is recommended use 2FA.")
            return 0
        opt_or_suff = re.match(
            "\s*auth\s*(optional|sufficient)\s*pam_google_authenticator.so*", sshd_pam)
        if opt_or_suff is not None:
            self._log.error(
                "Not use {} option in /etc/pam.d/sshd.".format(opt_or_suff.group()))

    def login_filter(self):
        if not ("allowusers" in self._sshd.getOptions()) or ("allowgroups" in self._sshd.getOptions()):
            self._log.error(
                "Filter users/groups with AllowUSers, and/or, AllowGroups.")

    def subsystem(self):
        if "subsystem" in self._sshd.getOptions():
            self._log.error("If you not really need {} disable it.".format(
                self._sshd["subsystem"]))

    def algorithm(self):
        with open("algorithm_blacklist", 'r') as f:
            blacklist = f.readlines()
        for item in blacklist:
            item_cleared = item.split(' ', 1)
            for x in self._sshd.conf:
                if len(x) > 1:
                    if item_cleared[0] in x[1]:
                        self._log.error(
                            "{} - {}".format(item_cleared[0], item_cleared[1][:-1]))
                        break

    def fail2ban(self):
        if not path.exists("/usr/bin/fail2ban-server"):
            self._log.error("Fail2ban not installed.")

class Config(object):

    def __init__(self):
        self._config_file = "/etc/schopenhauer.yaml"

        try:
            with open(self._config_file, "r") as f:
                self._configuration = yaml.load(f.read())["SSH"]
        except FileNotFoundError:
            with open(self._config_file, "w+") as f:
                # Duplicated an ugly, maybe we can list all non private SSHCheck memeber functions on runtime?
                default_values = {"SSH": {'root': True, 'port': True, 'logingracetime': True,
                    'passauthentication': True, 'TFA': True, 'login_filter': True,
                    'subsystem': True, 'algorithm': True, 'fail2ban': True}}

                yaml.dump(default_values, f, default_flow_style=False)
                self._configuration = yaml.load(str(default_values))["SSH"]

    def isEnabled(self, checker_str) -> bool:
        return self._configuration[checker_str]


if __name__ == "__main__":
    checker = SSHCheck()
    config = Config()

    checkers = {'root': checker.root, 'port': checker.port, 'logingracetime': checker.logingracetime,
            'passauthentication': checker.passauthentication, 'TFA': checker.TFA, 'login_filter': checker.login_filter,
            'subsystem': checker.subsystem, 'algorithm': checker.algorithm, 'fail2ban': checker.fail2ban}


    for name in sorted(checkers):
        if config.isEnabled(name):
            checkers[name]()
